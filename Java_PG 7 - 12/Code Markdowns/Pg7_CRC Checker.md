# CNS Lab Question 7 - CRC Generator

## Question

Write a program for error detecting code using CRC-CCITT (16- bits).

### Points to Note: -

* CCITT - Consultative Committee for International Telephony and Telegraphy
* CCITT is now known as ITU-T - International Telecommunications Union – Telecommunications Sector
* CRC - Cyclic Redundancy Check
* Advantages of CRC

> 1. CRC can detect all single-bit errors
> 2. CRC can detect all double-bit errors provided the divisor contains at least three logic 1’s.
> 3. CRC can detect any odd number of errors provided the divisor is a factor of x+1.
> 4. CRC can detect all burst error of length less than the degree of the polynomial.
> 5. CRC can detect most of the larger burst errors with a high probability.

* CRC 16 - CCITT Polynomial $x^{16} + x^{12} + x^5 + 1$ which is ${10001000000100001}$

## Program

### __Implementation 1: -__

#### _Similar to given manual_

```java
import java.util.Scanner;

public class CRC {
    void div(int[] a, int k) //crc 16bit division
    {
        int[] gp = {1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1}; //CRC-16-CCITT Expression
        int count = 0;
        for (int i = 0; i < k; i++) {
            if (a[i] == gp[0]) {
                for (int j = i; j < 17 + i; j++) {
                    // ^ is Bitwise XOR operation
                    a[j] = a[j] ^ gp[count++]; //long division
                }
                count = 0;
            }
        }
    }

    public static void main(String[] args) {
        int[] a = new int[100];
        int[] b = new int[100];

        int len, k;
        CRC ob = new CRC();

        System.out.println("Enter the length of Data Frame:");

        Scanner sc = new Scanner(System.in);
        len = sc.nextInt();

        int flag = 0;

        System.out.println("Enter the Message (enter 1 bit per line):");

        for (int i = 0; i < len; i++)
            a[i] = sc.nextInt();

        for (int i = 0; i < 16; i++)
            a[len++] = 0;

        k = len - 16;

        if (len >= 0) System.arraycopy(a, 0, b, 0, len); //For deep copy

        ob.div(a, k);

        for (int i = 0; i < len; i++)
            //user's message
            //division operation on client's side
            a[i] = a[i] ^ b[i];

        System.out.println("Data to be transmitted: ");
        for (int i = 0; i < len; i++)
            System.out.print(a[i] + " ");    //message sent from client's side

        System.out.println();
        System.out.println("Enter the Received Data: ");

        for (int i = 0; i < len; i++)
            a[i] = sc.nextInt();

        ob.div(a, k);

        for (int i = 0; i < len; i++) {
            if (a[i] != 0) {
                flag = 1;
                break;
            }
        }

        if (flag == 1)
            System.out.println("error in data");
        else
            System.out.println("no error");

        sc.close();
    }
}

```

### __Implementation 2: -__

#### _Little bit more foolproof_

```java
import java.util.Scanner;

public class CRCV2 {
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        int n;

        //Accept the input
        System.out.println("Enter the size of the data:");
        n = scan.nextInt();

        int data[] = new int[n];

        System.out.println("Enter the data, bit by bit:");
        for (int i = 0; i < n; i++) {
            data[i] = scan.nextInt();
        }

        int[] divisor = {1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1};

        // Divide the inputted data by the inputted divisor
        // Store the remainder that is returned by the method

        int[] remainder = divide(data, divisor);

        for (int i = 0; i < remainder.length - 1; i++) {
            System.out.print(remainder[i]);
        }
        System.out.println("\nThe CRC code generated is:");

        for (int i = 0; i < data.length; i++) {
            System.out.print(data[i]);
        }
        for (int i = 0; i < remainder.length - 1; i++) {
            System.out.print(remainder[i]);
        }
        System.out.println();

        // Create a new array
        // It will have the remainder generated by the above method appended
        // to the inputted data
        int[] sent_data = new int[data.length + remainder.length - 1];

        System.out.println("Enter the data to be sent:");

        for (int i = 0; i < sent_data.length; i++) {
            sent_data[i] = scan.nextInt();
        }
        receive(sent_data, divisor);
    }

    static int[] divide(int[] old_data, int[] divisor) {
        int[] remainder;
        int i;
        int[] data = new int[old_data.length + divisor.length];
        System.arraycopy(old_data, 0, data, 0, old_data.length);
        // Remainder array stores the remainder
        remainder = new int[divisor.length];
        // Initially, remainder's bits will be set to the data bits
        System.arraycopy(data, 0, remainder, 0, divisor.length);

        // Loop runs for same number of times as number of bits of data
        // This loop will continuously exor the bits of the remainder and
        // divisor
        for (i = 0; i < old_data.length; i++) {
            System.out.println((i + 1) + ".) First data bit is : " + remainder[0]);
            System.out.print("Remainder : ");
            if (remainder[0] == 1) {
                // We have to exor the remainder bits with divisor bits
                for (int j = 1; j < divisor.length; j++) {
                    remainder[j - 1] = exor(remainder[j], divisor[j]);
                    System.out.print(remainder[j - 1]);
                }
            } else {
                // We have to exor the remainder bits with 0
                for (int j = 1; j < divisor.length; j++) {
                    remainder[j - 1] = exor(remainder[j], 0);
                    System.out.print(remainder[j - 1]);
                }
            }
            // The last bit of the remainder will be taken from the data
            // This is the 'carry' taken from the dividend after every step
            // of division
            remainder[divisor.length - 1] = data[i + divisor.length];
            System.out.println(remainder[divisor.length - 1]);
        }
        return remainder;
    }

    static int exor(int a, int b) {
        // This simple function returns the exor of two bits
        if (a == b) {
            return 0;
        }
        return 1;
    }

    static void receive(int[] data, int[] divisor) {
        // This is the receiver method
        // It accepts the data and divisor (although the receiver already has
        // the divisor value stored, with no need for the sender to resend it)
        int[] remainder = divide(data, divisor);
        // Division is done
        for (int j : remainder) {
            if (j != 0) {
                // If remainder is not zero then there is an error
                System.out.println("There is an error in received data...");
                return;
            }
        }
        //Otherwise there is no error in the received  data
        System.out.println("Data was received without any error.");
    }
}
```
